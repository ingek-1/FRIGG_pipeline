#!/usr/bin/python
# coding=utf-8

"# INFO - this script takes a mysql table as input and selects the SM clusters that fulfill the selection requirements"
"# Selecting putative resistance gene and clusters"
# input - ik_prox_fam_count

# importing modules
# to read and write csv files, sys - to take arguments
import csv, sys
import argparse
import MySQLdb as mdb
from datetime import datetime
import time

start_time =datetime.now()

print "#---------------------------------------------------------------------------#"
print "#       Selecting SM gene clusters with potential resistance genes    "
print "#           based on gene copy numbers as selection criteria. "
print "#---------------------------------------------------------------------------#"

# connecting to the database
host = "XXX"
user = "user_name"
password = "***"
dbname = "database"
db = mdb.connect( host,user,password,dbname )
cursor = db.cursor()
# connect to DB
db = mdb.connect( host,user,password,dbname )
cursor = db.cursor()


"####### USER INPUT #######"

parser = argparse.ArgumentParser()
parser.add_argument("-input", "-i", required=False, default='prox_fam_count',
					 help="Set the Table to use as input - generated by the SMG_prox_fam.py.")
parser.add_argument("-output", "-o", required=False, default='StrictCase_WholeHFAM',
					 help="Set the Table to use as output, a table with all proteins from each hfam identified with putative resistance genes.")	
parser.add_argument("-smurf_table", "-s", required=False, default='smurf',
 					 help="Set which secondary metabolite prediction table to use (SMURF).")
parser.add_argument("-hfamTable", "-ht", required=False, default='hfam',
 					 help="Set the hfam table - table containing the protein families (column: hfam, org_id, org_name, protein_id")
parser.add_argument("-Overview_file", "-Of", required=False, default='*Overview_name*',
 					 help="The name of the overview output file with key numbers from the filtering process")

# user input for selection patterns and filtering criteria
parser.add_argument("-Hfam_cutoff", "-hc", required=False, default=10000,
 					 help="The cut off of the size of hfams that are disregarded concerning the count and pattern selection, set to 10000 to avoid this setting, step 2")
parser.add_argument("-Flag_moreClust", "-fmc", required=False, default=0,
 					 help="A flag whether filtering based on pot. resistance gene found in more than 1 cluster, step 3 (if =1 filtering is done if 0 filtering is not done)")
parser.add_argument("-Nhfam_org", "-Nho", required=False, default='90perc',
 					 help="Set the number of organism the protein family has to be found in (all/98perc/95perc/90perc), step 4")
parser.add_argument("-Flag_singleOrg", "-fso", required=False, default=1,
 					 help="A flag whether filtering based on the number of organisms having a single copy in the genome is implemented ot not, step 5 (if =1 filtering is done if 0 filtering is not done)")

args = parser.parse_args()



# set variables
input_table = args.input 				# Set the input table with the proteinfam and count
output_table = args.output 				# Set the output table
smurf_table = args.smurf_table 		# Set the smurf table
hfamTable = args.hfamTable 			# Set the protein_family table 
Name_overview = args.Overview_file 			# Set the name of the overview file with key numbers form filtering process

hfam_cutoff = args.Hfam_cutoff			# Set the cut off value for the size of hfams to be considered 
#hfam_cutoff is multipplied by the number of organisms in the set to get the biggest hfam that will be considered as pot resistance gene  
flag_more_cluster = args.Flag_moreClust 	# Set a flag that decided if filtering is done or not based on the number of cclusters a potential resistance gene family is found in
N_hfam_org = args.Nhfam_org 			# Set the cutoff for the number of organism the hfam should be found in
flag_single_org = args.Flag_singleOrg 	# Set a flag that decided if filtering is done or not based on the number of organism having a sinlge copy of the target gene

"################ NOTES to user: check these additional variables ############################"
intermediate_strict = 'StrictCase_genes_Pipeline_'+Name_overview
count_table = 'countfams' 
path = "/path/to/the/outputDirectory/"

Path_filename_best = path+"fasta_best_Pipeline_"+Name_overview+"/"
filename_all_best = Path_filename_best+"All_data_best.txt"
	

"# Printing the settings to the user #"
print "# The settings chosen are:"
print "# The number of organisms the potential resistance genes should be found in: ", N_hfam_org
print "# The cut off value for the size of hfams to be considered: ", hfam_cutoff
print "# The Flag_moreClust (1 - filtering, 0 - no filtering) is set to: ", flag_more_cluster
print "# The flag_single_org (1 - filtering, 0 - no filtering) is set to: ", flag_single_org
print "# The name for the overview and fasta file is named: ", Name_overview




"###### INPUT DATA CHECK #########"
print "# Checking the input data"
query = ""
query = ("SELECT * FROM " + input_table +";")
cursor.execute(query)
clust_count = cursor.fetchall()

query = ""
query = ("SELECT distinct org_id FROM " + input_table +";")
cursor.execute(query)
organism_ids = cursor.fetchall()
Nr_org_total = len(organism_ids)

query = ""
query = ("SELECT distinct u_clust_id FROM " + input_table +";")
cursor.execute(query)
clust_ids = cursor.fetchall()
Nr_clust_total = len(clust_ids)


Organism_ids = []
for org in organism_ids:
	Organism_ids.append(org[0])

print "# CHECK the number of organisms: ", len(organism_ids)
print "# Check the number of columns  in data input: ", len(clust_count[0][:])
print "# The number of clusters in the dataset: ", len(clust_ids)


"############# SELECTING RESISTANCE BASED ON STRICT SCENARIO ###############"
start_time_strict =datetime.now()
# Selecting the potential resistance clusters - strict case scenario: genecopy nr 1 for all in the cluster and one gene also has a copy outside
# or if hfam_cutoff has been set - then diregarding protein families bigger than that 
print "# Selecting the potential resistance genes based on strict case scenario"
clust_resist = []
gene_resist = []
gene_resist_org_count = []
hfam_size_cutoff = Nr_org_total*hfam_cutoff # Selecting the size of hfams that are disregarded concerning the count and pattern selection, input*number_org

# going through each cluster 
for clust_id in clust_ids:
	query = ""
	query = ("SELECT * FROM " + input_table +" WHERE u_clust_id = \'"+clust_id[0]+"\';")
	cursor.execute(query)
	cluster = cursor.fetchall()
	
	clust_count_sum = 0
	flag1 = 0
	flag2 = 0
	for i in range(len(cluster)):
		# Checking if the size of the hfam (nr of protein members in the hfam) is bigger than hfam_cutoff x the number of organisms in the dataset
		# If so - then the protein will be disregarded in the count and pattern selection process 
		if int(cluster[i][12]) <  hfam_size_cutoff:
			# sum of the gene count within the cluster - will be used to see if there is similar expression pattern of the genes
			clust_count_sum += cluster[i][8]
			# checking if one gene family is found once outside the cluster
			# flag1 is set to 1 when the first case of a copied gene is found
			# flag2 is set to one if there are more cases with copies or if there are more than one copy
			if cluster[i][10] > 1:
				flag2 = 1
			elif flag1 == 1 and cluster[i][10] > 0:
				flag2 = 1	
			elif cluster[i][10] ==1:
				flag1 = 1
		else:
			clust_count_sum = clust_count_sum + 1
			
	# Making a list of the potential resistance cluster ids
	if clust_count_sum == len(cluster) and flag1 ==1 and flag2 != 1:
		clust_resist.append(clust_id[0])
		print(clust_id)

Nr_StrictClust_total = len(clust_resist)
print "\nThe number of clusters meeting the requiremenst for the selection patterns is: ", len(clust_resist), "\n"

"############## Making a table with all the selected cluster genes ###############"
print "# Making table with the selected clusters:" + intermediate_strict
#drop table if it already exist
cursor.execute("DROP TABLE IF EXISTS "+ intermediate_strict+";")
# Create table as per requirement
cursor.execute("CREATE TABLE "+ intermediate_strict+" (\
			`org_id` int(11) NOT NULL, \
  			`org_name` varchar(100) NOT NULL, \
  			`u_clust_id` varchar(50) NOT NULL DEFAULT '', \
  			`clust_backbone` varchar(50) DEFAULT '', \
  			`hfam` int(100), \
  			`protein_id` varchar(100) NOT NULL DEFAULT '' \
			) ENGINE=MyISAM DEFAULT CHARSET=latin1;")
db.commit()

for clust_resist_id in clust_resist:
	
	query = ""
	query = ("SELECT org_id, org_name, u_clust_id, clust_backbone, hfam, protein_id  FROM "+ input_table +" \
			where u_clust_id = \'"+clust_resist_id+"\' and count_anywhere > 0 and size_hfam < ("+ str(hfam_size_cutoff) +") ;")
	cursor.execute(query)
	StrictCase_genes = cursor.fetchall()
	
	"# Make new table with the potential resistance genes (based on selection pattern) "
	query = ""
	query  = "INSERT INTO "+ intermediate_strict+" (org_id, org_name, u_clust_id, clust_backbone, hfam, protein_id) \
         VALUES (\'"+str(StrictCase_genes[0][0])+"\', \'"+str(StrictCase_genes[0][1])+"\', \'"+str(StrictCase_genes[0][2])+"\', \'"+str(StrictCase_genes[0][3])+"\', \'"+str(StrictCase_genes[0][4])+"\', \'"+str(StrictCase_genes[0][5])+"\');"
	try:
		# Execute the SQL command
		cursor.execute(query)
		# Commit your changes in the database
		db.commit()
	#except:
	except  mdb.Error, e:
		# Rollback in case there is any error
   		db.rollback()
		print gene_resist_count[i]
		sys.exit("# ERROR mysql %d: %s" % ( e.args[0],e.args[1] ))


"# FILTERING & SELECTING "
print "# Filter and select the hfam found in at least two strict cases if flag_more_cluster=1 plus make the output table"
# Selecting the selected case genes where the hfam is also found in another strict case gene
# getting the potential resistance genes where the hfam is shared with other potential resistance genes 

if flag_more_cluster == 1:
	query = (" SELECT hfam from ( \
				SELECT *, count(hfam) as c_hfam FROM ( \
					SELECT * FROM "+ intermediate_strict +" \
					group by hfam, u_clust_id) as ta \
				group by hfam) as tb \
			where c_hfam > 1; 	")
elif flag_more_cluster == 0 :
	query = ("SELECT distinct hfam FROM "+ intermediate_strict +";")


cursor.execute(query)
hfam_StrictCase = cursor.fetchall()

"############## Making a table with all the strict case cluster genes ###############"
#drop table if it already exist
cursor.execute("DROP TABLE IF EXISTS `"+output_table+"`;")
# Create table as per requirement
cursor.execute("CREATE TABLE `"+output_table+"` (\
			`hfam` int(100), \
			`org_id` int(11) NOT NULL, \
  			`org_name` varchar(100) NOT NULL, \
  			`real_name` varchar(100) DEFAULT '', \
	  		`section` varchar(100) DEFAULT '', \
  			`protein_id` varchar(100) NOT NULL DEFAULT '', \
  			`prot_seq` longblob, \
  			`flag` varchar(100) DEFAULT '', \
  			`count` int(100) \
			) ENGINE=MyISAM DEFAULT CHARSET=latin1;")
db.commit()

if flag_more_cluster == 1:
	print "\nThe number of protein families found in more strict case clusters: ", len(hfam_StrictCase)
elif flag_more_cluster == 0 :
	print "\nThe number of protein families found in strict cases: ", len(hfam_StrictCase)

# Getting all the protein families (hfam) containinga putative resistance gene and inserting information into output table
for hfam in hfam_StrictCase:
	print(hfam)
	query = ""
	query = ("SELECT PF.hfam, PF.org_id, PF.org_name, organism.real_name, organism.section, PF.protein_id, proteins.prot_seq, ik.protein_id as StrictClust_flag, ss.clust_backbone as Clust_flag, ss2.org_id, ik_countfams.count  FROM "+hfamTable+" as PF \
				LEFT JOIN "+ intermediate_strict+" as ik ON PF.org_id = ik.org_id and PF.protein_id =ik.protein_id \
				LEFT JOIN " + smurf_table +" as ss ON ss.org_id = PF.org_id and ss.sm_protein_id = PF.protein_id \
				INNER JOIN (SELECT distinct(org_id) FROM " + smurf_table +") as ss2 ON ss2.org_id = PF.org_id \
				JOIN organism ON (PF.org_id = organism.org_id ) \
				JOIN proteins ON (PF.org_id = proteins.org_id AND proteins.prot_seqkey = PF.protein_id) \
				LEFT JOIN "+ count_table +" as ik_countfams ON (ik_countfams.org_id = PF.org_id AND ik_countfams.hfam = PF.hfam) \
				where PF.hfam = \'"+str(hfam[0])+"\' \
				group by PF.org_id, PF.protein_id \
				Order by PF.org_id;")

	cursor.execute(query)
	hfam_genes = cursor.fetchall()

	query = ""
	query = "SELECT org_id as outside_flag FROM( \
				SELECT PF.hfam, PF.org_id, PF.org_name, PF.protein_id, ik.protein_id as StrictClust_flag FROM "+hfamTable+" as PF \
				LEFT JOIN "+ intermediate_strict+" as ik ON PF.org_id = ik.org_id and PF.protein_id =ik.protein_id \
				INNER JOIN (SELECT distinct(org_id) FROM " + smurf_table +") as ss2 ON ss2.org_id = PF.org_id \
				where PF.hfam = \'"+str(hfam[0])+"\') as ta \
				where protein_id = StrictClust_flag;"
	cursor.execute(query)
	org_outside = cursor.fetchall()
	
	# getting the organism where the strict case are found - will be used to identify the outsideC genes
	Org_ids_outside = []
	for org in org_outside:
		Org_ids_outside.append(org[0])
	
	# For each gene check for flag situations - in a cluster, in a strict cluster eller outsideSC
	flag = '0'
	for gene in hfam_genes:
		if gene[7] != None:
			flag = 'StrictClust'
		elif gene[8] != None:
			flag = 'Clust'

		if gene[1] in Org_ids_outside and flag !='StrictClust':
			flag = 'outsideSC'
		
		# insert into table hfam, org_id, org_name, 
		"# Insert values into new output table (default: ik_StrictCase_WholeHFAM)"
		query = ""
		query  = "INSERT INTO `"+output_table+"` (hfam, org_id, org_name, real_name, section, protein_id, prot_seq, flag, count) \
        	 VALUES (\'"+str(gene[0])+"\', \'"+str(gene[1])+"\', \'"+str(gene[2])+"\', \'"+str(gene[3])+"\', \'"+str(gene[4])+"\', \'"+str(gene[5])+"\', \'"+str(gene[6])+"\', \'"+str(flag)+"\', \'"+str(gene[10])+"\');"
		try:
			# Execute the SQL command
			cursor.execute(query)
			# Commit your changes in the database
			db.commit()
		#except:
		except  mdb.Error, e:
			# Rollback in case there is any error
	   		db.rollback()
			print gene
			sys.exit("# ERROR mysql %d: %s" % ( e.args[0],e.args[1] ))

		# Reset flag - ready for next round 
		flag = '0'

print "# INFO Runtime for selecting cases: ", (datetime.now()-start_time_strict)




"############# Creating output files #####################"
start_time_files = datetime.now()


"#################### Filtering step 4 and 5 ######################"

'###### Selecting the hfam where a specific percentage of org have the hfam #######'
# making a file with the hfam found in every organism and not found more ..
# columns: hfam, d_count (distinct org_id), s_count (count total sum), single_count (count org where hfam found once)
# the d_count = max, 	

print "# Selecting the hfam found in a specific percentage of the organisms: "
if N_hfam_org== 'all':
	Number_hfam = str(len(organism_ids))
elif N_hfam_org== '98perc':
	Number_hfam = str(int(round(float(len(organism_ids))/100*98)))
elif N_hfam_org== '95perc':
	Number_hfam = str(int(round(float(len(organism_ids))/100*95)))
elif N_hfam_org== '90perc':
	Number_hfam = str(int(round(float(len(organism_ids))/100*90)))
elif N_hfam_org== 'test':
	Number_hfam = str(int(round(float(len(organism_ids))/100*80)))
else:
	print"\nERROR: please selected one of the possible percentages in the input (all/98perc/95perc/90perc)\n"

if flag_single_org == 1:
	"# filtering based on how many organism that can have more copies of the potential resistance gene/target"
	min_hfam_count = str(int(round(float(len(organism_ids))/100*50)))
	query = ""
	query ="SELECT * FROM ( \
			SELECT HFAM, count(distinct org_id)as d_count, SUM(count) as s_count, SUM(count<2) as single_count FROM ( \
				SELECT *FROM `"+output_table+"` \
				GROUP BY hfam, org_id) as ta \
			GROUP BY hfam) as tb \
		where d_count>=\'"+Number_hfam+"\' AND single_count >= \'"+min_hfam_count+"\' \
		ORDER BY s_count ASC;"
	cursor.execute(query)
	hfam_best = cursor.fetchall()
	print "\nThe number of hfam found in ", Number_hfam, "but not more than once in ", min_hfam_count, " organisms or more is: ", len(hfam_best)

elif flag_single_org == 0 :
	"# Getting the hfam fulfilling the number of organisms it should be found in"
	query = ""
	query = "SELECT * FROM ( \
			SELECT HFAM, count(distinct org_id)as d_count, SUM(count) as s_count, SUM(count<2) as single_count FROM ( \
				SELECT *FROM `"+output_table+"` \
				GROUP BY hfam, org_id) as ta \
			GROUP BY hfam) as tb \
		where d_count>=\'"+Number_hfam+"\' \
		ORDER BY s_count ASC;"
	cursor.execute(query)
	hfam_best = cursor.fetchall()
	print "\nThe number of hfam found in ", Number_hfam, "organisms or more is: ", len(hfam_best)



"# Making a csv table with best protein families (hfam) found in selected percentage of the organisms"
# Making output files - csv format
	# columns: hfam, d_count (distinct org_id), s_count (count total sum), single_count (count org where hfam found once)
filename_info = Path_filename_best+"Info_best_hfam.csv"
 
f = open(filename_info,'wb')
try: 
	writer = csv.writer(f, delimiter = ';')
	writer.writerow(("hfam", "d_count", "s_count", "single_count"))
	for item in hfam_best:
		writer.writerow(item)
finally:
	f.close()

print "# Making fasta files with the best hfam in folder:" + filename_all_best

outfile_all_best = open(filename_all_best, 'w')


print "# The best hfam: "
for hfam in hfam_best:
	print "hfam: ", hfam[0]

	query = ""
	query = "SELECT org_id, org_name, real_name, section, protein_id, count, flag, prot_seq FROM `"+output_table+"` \
				where hfam = \'"+str(hfam[0])+"\';"  

	cursor.execute(query)
	hfam_genes_fasta = cursor.fetchall()

	filename_best = Path_filename_best+str(hfam[0])+"_BallGenes.fasta"
	maxChars = 80
	
	outfile_best = open(filename_best, 'w')

	# create fasta file containing all the genes beloning to the hfam 
	for gene in hfam_genes_fasta:
		# in some real_names there are ' ' some following programs then stops the name after ' ' so this is replaced with '_'
		if ' ' in gene[2]:
			name = gene[1][0] + '.' + gene[2].replace(" ", "_") + '_' + gene[3] + '_' + gene[4] +'_c' + str(gene[5]) +'_' + gene[6]
		else:
			name = gene[1][0] + '.' + gene[2] + '_' + gene[3] + '_' + gene[4] +'_c' + str(gene[5])+'_' + gene[6]
		
		Seq = gene[7]
		outfile_best.write('>' + name +'\n')
		for i in range(0, len(Seq), maxChars):		# making each line of the seq max 80 characters 
			outfile_best.write(Seq[i:i+maxChars]+"\n")
	outfile_best.close()
	# making a text file containing all the filenames and paths for the protein sequences for each hfam
	outfile_all_best.write(Path_filename_best +str(hfam[0])+ "_BallGenes.fasta\n")

	
outfile_all_best.close()	

print "# INFO Total Runtime for making files: ", (datetime.now()-start_time_files)

"*********************************************** Output with key numbers ***********************************************"
"# Creating an output file with the main numbers for comparison of the changes in the output based on changes in varibles"
# Creating alist to collect all the main numbers
Main_numbers=[]
# The number of org in the dataset
Nr_org = ('Nr_org', Nr_org_total)
Main_numbers.append(Nr_org)
# The total number of predicted clusters
Nr_clust = ('Nr_clust', Nr_clust_total)
Main_numbers.append(Nr_clust)
# The number of Strict clusters following the selcted pattern
Nr_StrictClust = ('Nr_StrictClust', Nr_StrictClust_total)
Main_numbers.append(Nr_StrictClust)
# The number of Strict clusters where at least one other cluster has the same potential resistance
Nr_MoreThan1 = ('Nr_MoreThan1', len(hfam_StrictCase))
Main_numbers.append(Nr_MoreThan1)
# The number of strict clust where the potential resiatnce gene is found in x% of the organisms 
# and if Flag_singleOrg is 1 then how many that have single copies in 50% of the organisms
Nr_Xorg = ('Org_Nr_StrictClust', len(hfam_best))
Main_numbers.append(Nr_Xorg)

print Main_numbers

# make name dependent on N_hfam_org and hfam_size x3 or 2... make it a varible and put it as part of the name!
filename_Overview = path+"Overview_"+ Name_overview+".csv"
	
f = open(filename_Overview,'wb')
try: 
	writer = csv.writer(f, delimiter = ';')
	writer.writerow(("Description", "Number"))
	for item in Main_numbers:
		writer.writerow(item)
finally:
	f.close()


"################## End check - the number of input and output org ############################"
print "\n# End check - the number of org in the output the same as the input"
query = ""
query = ("SELECT distinct org_id FROM " + intermediate_strict +";")
cursor.execute(query)
out_organism_ids = cursor.fetchall()


if len(organism_ids) == len(out_organism_ids):
	print "Successful check! The number of input org fits the number of output org."
else:
	print "There is a problem with the number of org"
	print "The number of input org: ", len(organism_ids)
	print "The number of output org: ", len(out_organism_ids)



# closing database
cursor.close()
db.close()

print "# INFO Total Runtime for SMG_prox_fam: ", (datetime.now()-start_time)
print "\n# Done - the End"

